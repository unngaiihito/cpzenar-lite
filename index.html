<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cpzenar – 無限スロット（追記/上書き/Done・フォールバックON）</title>
  <meta name="theme-color" content="#0b0b0c">
  <link rel="manifest" href="/manifest.webmanifest">
  <!-- 可能ならアイコンも用意（省略可）
  <link rel="icon" href="/icons/icon-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="/icons/icon-192.png">
  -->
  <style>
    :root { --bg:#0b0b0c; --fg:#f5f6f7; --mut:#a9acb2; --acc:#4f8cff; --ok:#00c37a; --warn:#ffb020; --bad:#ff5a5a; --panel:#141518; --border:#23252a; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans JP',sans-serif}
    .wrap{max-width:900px;margin:0 auto;padding:16px}
    h1{font-size:18px;margin:0 0 10px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{flex:1;min-width:240px;background:var(--panel);border:1px solid var(--border);border-radius:12px;color:#fff;padding:10px}
    .search{max-width:320px}
    textarea{width:100%;min-height:3.2em;max-height:6.4em;resize:vertical;background:var(--panel);border:1px solid var(--border);border-radius:12px;color:#fff;padding:12px;margin-top:8px}
    .btn{background:#23252a;border:none;color:#e8eaed;border-radius:10px;padding:10px 12px;cursor:pointer}
    .btn.acc{background:var(--acc);color:#fff}
    .btn.danger{background:#2b1619;border:1px solid #5a1f26}
    .mini{font-size:12px;padding:6px 8px;margin-left:4px}
    .hint{color:var(--mut);font-size:12px;margin:6px 0 2px}
    .section{margin-top:12px}
    .tabs{display:flex;gap:8px;margin-top:8px}
    .tab{padding:8px 10px;border:1px solid var(--border);border-radius:10px;cursor:pointer;color:#d6d7db;background:#15161b;display:flex;gap:8px;align-items:center}
    .tab.on{background:#1b1d24;border-color:#2b2f38}
    .right{margin-left:auto;display:flex;gap:8px;align-items:center}
    .listshell{margin-top:10px;border:1px solid var(--border);border-radius:12px;height:58vh;min-height:280px;display:flex;flex-direction:column}
    .listhead{display:flex;align-items:center;gap:8px;padding:8px 10px;border-bottom:1px solid #1e2026;background:#121318}
    .listwrap{flex:1;overflow:auto}
    .list{min-height:100%}
    .item{display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center;padding:10px 12px;border-top:1px solid #1e2026}
    .item:first-child{border-top:none}
    .item:hover{background:#121318}
    .name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ts{color:#9aa0a6;font-size:12px}
    .empty{padding:18px;color:#aaa;text-align:center}
    .toast{position:fixed;inset:0;display:none;place-items:center;background:rgba(0,0,0,.45)}
    .toast.show{display:grid}
    .toast .box{background:#0e1713;border:1px solid #163d2d;padding:18px;border-radius:14px;color:#d9f7e9}
    footer{background:#fafafa}
    footer a{color:#0366d6;text-decoration:none}
    footer a:hover{text-decoration:underline}
  </style>
</head>

<body>
<div class="wrap">
  <h1>無限スロット（行クリック=追記 / 右の［上書き］・［✖］）</h1>

  <!-- 追加行 -->
  <div class="row">
    <input id="slotName" type="text" placeholder="新しいスロット名を入力して［追加］">
    <button class="btn acc" id="addBtn">追加</button>
    <button class="btn" id="exportBtn">エクスポート(JSON)</button>
    <button class="btn" id="importBtn">インポート(JSON)</button>
  </div>

  <!-- スロット関連（まとめて配置） -->
  <div class="section">
    <div class="tabs">
      <div class="tab on" data-tab="slots">スロット</div>
      <div class="tab" data-tab="stash">
        一時保存（上書きの旧版）
        <span class="right"><button class="btn mini danger" id="clearStash">一時保存を空にする</button></span>
      </div>
      <div class="tab" data-tab="done">
        Done（✖で退避）
        <span class="right"><button class="btn mini danger" id="clearDone">Doneを空にする</button></span>
      </div>
    </div>

    <div class="listshell">
      <div class="listhead">
        <input class="search" id="searchInput" type="text" placeholder="スロット名で検索（前方一致・空で全件）">
        <span class="right" style="color:#9aa0a6;font-size:12px">保存数が多くても快適にスクロールできます</span>
      </div>
      <div class="listwrap">
        <div id="list" class="list"></div>
        <div id="empty" class="empty" style="display:none">項目がありません</div>
      </div>
    </div>
  </div>

  <!-- フォールバック用の小さめテキスト欄 -->
  <textarea id="note" placeholder="★この欄に“追記したいテキスト”を書いておくと、行クリックでそのまま追記（フォールバックON）。クリップボードが読める場合は、先にクリップボードを使用します。"></textarea>
  <div class="hint">保存時の入力優先順：<strong>クリップボード</strong> →（空/不可なら）<strong>このテキスト欄</strong></div>
</div>

<div class="toast" id="toast"><div class="box" id="toastMsg">OK</div></div>

<!-- フッター（ご指定の内容） -->
<footer style="margin-top:48px;padding:16px 12px;border-top:1px solid #eee;font:14px/1.6 system-ui,-apple-system,'Segoe UI',Roboto,'Noto Sans JP',sans-serif;background:#fafafa">
  <nav style="display:flex;gap:16px;flex-wrap:wrap">
    <a href="/legal/tokushoho.html">特定商取引法に基づく表記</a>
    <a href="/legal/refund.html">返金・キャンセルポリシー</a>
    <a href="/legal/terms.html">利用規約</a>
    <a href="/legal/privacy.html">プライバシーポリシー</a>
    <a href="mailto:cpzenar.contact@gmail.com">お問い合わせ</a>
    <span style="margin-left:auto;color:#666">© CPZENAR Labs</span>
  </nav>
</footer>

<script>
/* ===== 設定 ===== */
const USE_FALLBACK = true; // フォールバックON

/* ===== IndexedDB (slots / stash / done) ===== */
const DBN='cpzenar_db_v3';
const STORES={ slots:'slots', stash:'stash', done:'done' };
let db;
function openDB(){
  return new Promise((res,rej)=>{
    const r=indexedDB.open(DBN,1);
    r.onupgradeneeded=()=>{ const d=r.result;
      Object.values(STORES).forEach(s=>{
        if(!d.objectStoreNames.contains(s)){
          const os=d.createObjectStore(s,{keyPath:'id',autoIncrement:true});
          os.createIndex('by_updated','updatedAt',{unique:false});
          os.createIndex('by_name','name',{unique:false});
          os.createIndex('by_saved','savedAt',{unique:false}); // stash/done向け
        }
      });
    };
    r.onsuccess=()=>{db=r.result; res(db);}
    r.onerror=e=>rej(e);
  });
}
async function tx(store, mode, fn){
  await openDB();
  return new Promise((res,rej)=>{
    const t=db.transaction(store, mode); const os=t.objectStore(store);
    fn(os,t); t.oncomplete=()=>res(); t.onerror=e=>rej(e);
  });
}
async function getAll(store, index='by_updated', dir='prev'){
  await openDB();
  return new Promise((res,rej)=>{
    const out=[]; const t=db.transaction(store,'readonly'); const os=t.objectStore(store).index(index);
    const c=os.openCursor(null,dir);
    c.onsuccess=()=>{ const cur=c.result; if(!cur){res(out);return;} out.push(cur.value); cur.continue(); };
    c.onerror=e=>rej(e);
  });
}
async function getByName(name){
  await openDB();
  return new Promise((res,rej)=>{
    const t=db.transaction(STORES.slots,'readonly'); const os=t.objectStore(STORES.slots).index('by_name');
    const out=[]; const req=os.openCursor(IDBKeyRange.only(name));
    req.onsuccess=()=>{ const cur=req.result; if(!cur){res(out);return;} out.push(cur.value); cur.continue(); };
    req.onerror=e=>rej(e);
  });
}
async function put(store, val){ await tx(store,'readwrite',(os)=>os.put(val)); }
async function del(store, id){ await tx(store,'readwrite',(os)=>os.delete(id)); }
async function clearStore(store){ await tx(store,'readwrite',(os)=>os.clear()); }

/* ===== Utils ===== */
const now=()=>Date.now();
function fmtTs(ms){ try{ return new Date(ms).toLocaleString(); }catch{return ''} }
function toast(msg){ const t=document.getElementById('toast'), m=document.getElementById('toastMsg'); m.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1200); }

/* クリップボード→フォールバック順で取得 */
async function getInputText(){
  try{
    const s=await navigator.clipboard.readText();
    if (s && s.trim()) return s;
  }catch{}
  if (USE_FALLBACK) {
    const fb=document.getElementById('note').value||'';
    if (fb && fb.trim()) return fb;
  }
  return '';
}

/* ===== Core ops ===== */
async function addSlotByName(name, content){
  const rec={ name, content, updatedAt:now() };
  await put(STORES.slots, rec);
}
async function appendToSlot(rec){
  const text=await getInputText();
  if(!text){ toast('保存できるテキストがありません（クリップボード/テキスト欄とも空）'); return; }
  const sep = rec.content && !rec.content.endsWith('\n') ? '\n' : '';
  rec.content = (rec.content||'') + sep + text;
  rec.updatedAt = now();
  await put(STORES.slots, rec);
  toast('追記して保存しました');
}
async function overwriteSlot(rec){
  const text=await getInputText();
  if(!text){ toast('保存できるテキストがありません'); return; }
  const stashRec={ name:rec.name, content:rec.content, originId:rec.id, savedAt:now(), updatedAt:now() };
  await put(STORES.stash, stashRec);
  rec.content = text;
  rec.updatedAt = now();
  await put(STORES.slots, rec);
  toast('上書きしました（旧版は一時保存へ）');
}
async function removeToDone(rec){
  const doneRec={ name:rec.name, content:rec.content, originId:rec.id, savedAt:now(), updatedAt:now() };
  await put(STORES.done, doneRec);
  await del(STORES.slots, rec.id);
  toast('Doneへ移動しました');
}

/* ===== UI ===== */
const $name=document.getElementById('slotName');
const $add=document.getElementById('addBtn');
const $list=document.getElementById('list');
const $empty=document.getElementById('empty');
const $export=document.getElementById('exportBtn');
const $import=document.getElementById('importBtn');
const $tabs=document.querySelectorAll('.tab');
const $clearStash=document.getElementById('clearStash');
const $clearDone=document.getElementById('clearDone');
const $search=document.getElementById('searchInput');
let currentTab='slots';
let searchWord='';

$name.value = localStorage.getItem('last_slot_name')||'';
$name.addEventListener('input',()=>localStorage.setItem('last_slot_name',$name.value));

$add.onclick=async()=>{
  const nm=($name.value||'').trim(); if(!nm){ toast('スロット名を入力'); return; }
  const dup=await getByName(nm);
  if(dup.length){ toast('同名のスロットがあります'); return; }
  const text=await getInputText();
  if(!text){ toast('保存できるテキストがありません'); return; }
  await addSlotByName(nm, text);
  $name.value=''; localStorage.removeItem('last_slot_name');
  await render();
  toast('作成しました');
};

$search.addEventListener('input', ()=>{ searchWord=$search.value.trim().toLowerCase(); render(); });

async function render(){
  let data=[];
  if(currentTab==='slots') data=await getAll(STORES.slots);
  if(currentTab==='stash') data=await getAll(STORES.stash,'by_saved','prev');
  if(currentTab==='done')  data=await getAll(STORES.done,'by_saved','prev');

  if(currentTab==='slots' && searchWord){
    data = data.filter(x => (x.name||'').toLowerCase().startsWith(searchWord));
  }

  $list.innerHTML='';
  if(!data.length){ $empty.style.display='block'; return; }
  $empty.style.display='none';

  for(const rec of data){
    const row=document.createElement('div'); row.className='item';
    const left=document.createElement('div');
    const name=document.createElement('div'); name.className='name'; name.textContent=rec.name;
    const ts=document.createElement('div'); ts.className='ts';
    ts.textContent = currentTab==='slots' ? `更新: ${fmtTs(rec.updatedAt)}` : `退避: ${fmtTs(rec.savedAt)}`;
    left.appendChild(name); left.appendChild(ts);

    const btnOverwrite=document.createElement('button');
    btnOverwrite.className='btn mini'; btnOverwrite.textContent='上書き';

    const btnDel=document.createElement('button');
    btnDel.className='btn mini danger'; btnDel.textContent='✖';

    if(currentTab==='slots'){
      row.style.cursor='pointer';
      row.addEventListener('click', async (e)=>{
        if(e.target===btnOverwrite || e.target===btnDel) return;
        await appendToSlot(rec);
        await render();
      });
      btnOverwrite.onclick=async (e)=>{ e.stopPropagation(); await overwriteSlot(rec); await render(); };
      btnDel.onclick=async (e)=>{ e.stopPropagation(); await removeToDone(rec); await render(); };
    } else {
      btnOverwrite.disabled=true; btnDel.disabled=true;
      btnOverwrite.title='このタブでは操作できません';
      btnDel.title='このタブでは操作できません';
    }

    row.appendChild(left);
    row.appendChild(btnOverwrite);
    row.appendChild(btnDel);
    $list.appendChild(row);
  }
}

$tabs.forEach(t=>t.addEventListener('click',()=>{ $tabs.forEach(x=>x.classList.remove('on')); t.classList.add('on'); currentTab=t.dataset.tab; render(); }));

$clearStash?.addEventListener('click', async (e)=>{ e.stopPropagation(); if(confirm('一時保存をすべて削除します。よろしいですか？')){ await clearStore(STORES.stash); toast('一時保存を空にしました'); render(); }});
$clearDone?.addEventListener('click', async (e)=>{ e.stopPropagation(); if(confirm('Doneをすべて削除します。よろしいですか？')){ await clearStore(STORES.done); toast('Doneを空にしました'); render(); }});

$export.onclick=async()=>{
  const items=await getAll(STORES.slots);
  const blob=new Blob([JSON.stringify(items,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download=`slots-${new Date().toISOString().slice(0,10)}.json`;
  a.click(); URL.revokeObjectURL(a.href);
};
$import.onclick=async()=>{
  const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
  inp.onchange=async ()=>{
    const f=inp.files?.[0]; if(!f) return;
    const text=await f.text();
    let arr=[]; try{ arr=JSON.parse(text)||[]; }catch{ toast('JSONが不正です'); return; }
    if(!Array.isArray(arr)){ toast('JSON配列ではありません'); return; }
    for(const x of arr){
      if(!x.name || typeof x.content!=='string') continue;
      await put(STORES.slots, { name:String(x.name), content:String(x.content), updatedAt:now() });
    }
    await render(); toast('インポートしました');
  };
  inp.click();
};

/* 起動 */
(async function init(){
  await openDB();
  await render();
  // PWA用SW登録（存在すれば）
  if ('serviceWorker' in navigator) {
    try { await navigator.serviceWorker.register('/service-worker.js'); } catch {}
  }
})();
</script>
</body>
</html>
